<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DDC Tool: basic_json::basic_json</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DDC Tool
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">basic_json::basic_json</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="fragment"><div class="line"><span class="comment">// 1</span></div>
<div class="line">basic_json(<span class="keyword">const</span> value_t v);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2</span></div>
<div class="line">basic_json(std::nullptr_t = <span class="keyword">nullptr</span>) noexcept;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3</span></div>
<div class="line">template&lt;typename CompatibleType&gt;</div>
<div class="line">basic_json(CompatibleType&amp;&amp; val) noexcept(noexcept(</div>
<div class="line">           JSONSerializer&lt;U&gt;::to_json(<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::declval&lt;basic_json_t&amp;&gt;(),</div>
<div class="line">                                      <a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::forward&lt;CompatibleType&gt;(val))));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 4</span></div>
<div class="line">template&lt;typename BasicJsonType&gt;</div>
<div class="line">basic_json(const BasicJsonType&amp; val);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 5</span></div>
<div class="line">basic_json(initializer_list_t init,</div>
<div class="line">           <span class="keywordtype">bool</span> type_deduction = true,</div>
<div class="line">           value_t manual_type = value_t::<a class="code hl_class" href="../../d2/d41/classarray.html">array</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 6</span></div>
<div class="line">basic_json(size_type cnt, const basic_json&amp; val);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 7</span></div>
<div class="line">basic_json(iterator first, iterator last);</div>
<div class="line">basic_json(const_iterator first, const_iterator last);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 8</span></div>
<div class="line">basic_json(const basic_json&amp; other);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 9</span></div>
<div class="line">basic_json(basic_json&amp;&amp; other) noexcept;</div>
<div class="ttc" id="aclassarray_html"><div class="ttname"><a href="../../d2/d41/classarray.html">array</a></div><div class="ttdef"><b>Definition</b> unit-regression1.cpp:1604</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="../../d8/dcc/namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
</div><!-- fragment --><ol type="1">
<li>Create an empty JSON value with a given type. The value will be default initialized with an empty value which depends on the type:</li>
</ol>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value type   </th><th class="markdownTableHeadNone">initial value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">null   </td><td class="markdownTableBodyNone"><code>#!json null</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">boolean   </td><td class="markdownTableBodyNone"><code>#!json false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone"><code>#!json ""</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">number   </td><td class="markdownTableBodyNone"><code>#!json 0</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">object   </td><td class="markdownTableBodyNone"><code>#!json {}</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">array   </td><td class="markdownTableBodyNone"><code>#!json []</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">binary   </td><td class="markdownTableBodyNone">empty array   </td></tr>
</table>
<ol type="1">
<li>Create a <code>#!json null</code> JSON value. It either takes a null pointer as parameter (explicitly creating <code>#!json null</code>) or no parameter (implicitly creating <code>#!json null</code>). The passed null pointer itself is not read &ndash; it is only used to choose the right constructor.</li>
<li><p class="startli">This is a "catch all" constructor for all compatible JSON types; that is, types for which a <code>to_json()</code> method exists. The constructor forwards the parameter <code>val</code> to that method (to <code>json_serializer&lt;U&gt;::to_json</code> method with <code>U = uncvref_t&lt;CompatibleType&gt;</code>, to be exact).</p>
<p class="startli">Template type <code>CompatibleType</code> includes, but is not limited to, the following types:</p><ul>
<li><b>arrays</b>: <a class="el" href="../../d9/db4/md_thirdParty_2json-develop_2doc_2mkdocs_2docs_2api_2basic__json_2array__t.html">`array_t`</a> and all kinds of compatible containers such as <code>std::vector</code>, <code>std::deque</code>, <code>std::list</code>, <code>std::forward_list</code>, <code>std::array</code>, <code>std::valarray</code>, <code>std::set</code>, <code>std::unordered_set</code>, <code>std::multiset</code>, and <code>std::unordered_multiset</code> with a <code>value_type</code> from which a <code>basic_json</code> value can be constructed.</li>
<li><b>objects</b>: <a class="el" href="../../de/d2a/md_thirdParty_2json-develop_2doc_2mkdocs_2docs_2api_2basic__json_2object__t.html">`object_t`</a> and all kinds of compatible associative containers such as <code>std::map</code>, <code>std::unordered_map</code>, <code>std::multimap</code>, and <code>std::unordered_multimap</code> with a <code>key_type</code> compatible to <code>string_t</code> and a <code>value_type</code> from which a <code>basic_json</code> value can be constructed.</li>
<li><b>strings</b>: <code>string_t</code>, string literals, and all compatible string containers can be used.</li>
<li><b>numbers</b>: <a class="el" href="../../df/d5d/md_thirdParty_2json-develop_2doc_2mkdocs_2docs_2api_2basic__json_2number__integer__t.html">`number_integer_t`</a>, <a class="el" href="../../da/d55/md_thirdParty_2json-develop_2doc_2mkdocs_2docs_2api_2basic__json_2number__unsigned__t.html">`number_unsigned_t`</a>, <a class="el" href="../../de/d18/md_thirdParty_2json-develop_2doc_2mkdocs_2docs_2api_2basic__json_2number__float__t.html">`number_float_t`</a>, and all convertible number types such as <code>int</code>, <code>size_t</code>, <code>int64_t</code>, <code>float</code> or <code>double</code> can be used.</li>
<li><b>boolean</b>: <code>boolean_t</code> / <code>bool</code> can be used.</li>
<li><b>binary</b>: <code>binary_t</code> / <code>std::vector&lt;uint8_t&gt;</code> may be used; unfortunately because string literals cannot be distinguished from binary character arrays by the C++ type system, all types compatible with <code>const char*</code> will be directed to the string constructor instead. This is both for backwards compatibility, and due to the fact that a binary type is not a standard JSON type.</li>
</ul>
<p class="startli">See the examples below.</p>
</li>
<li><p class="startli">This is a constructor for existing <code>basic_json</code> types. It does not hijack copy/move constructors, since the parameter has different template arguments than the current ones.</p>
<p class="startli">The constructor tries to convert the internal <code>m_value</code> of the parameter.</p>
</li>
<li><p class="startli">Creates a JSON value of type array or object from the passed initializer list <code>init</code>. In case <code>type_deduction</code> is <code>#!cpp true</code> (default), the type of the JSON value to be created is deducted from the initializer list <code>init</code> according to the following rules:</p><ol type="a">
<li>If the list is empty, an empty JSON object value <code>{}</code> is created.</li>
<li>If the list consists of pairs whose first element is a string, a JSON object value is created where the first elements of the pairs are treated as keys and the second elements are as values.</li>
<li>In all other cases, an array is created.</li>
</ol>
<p class="startli">The rules aim to create the best fit between a C++ initializer list and JSON values. The rationale is as follows:</p><ol type="a">
<li>The empty initializer list is written as <code>#!cpp {}</code> which is exactly an empty JSON object.</li>
<li>C++ has no way of describing mapped types other than to list a list of pairs. As JSON requires that keys must be of type string, rule 2 is the weakest constraint one can pose on initializer lists to interpret them as an object.</li>
<li>In all other cases, the initializer list could not be interpreted as JSON object type, so interpreting it as JSON array type is safe.</li>
</ol>
<p class="startli">With the rules described above, the following JSON values cannot be expressed by an initializer list:</p><ul>
<li>the empty array (<code>#!json []</code>): use <code><a class="el" href="../../d2/d41/classarray.html">array(initializer_list_t)</a></code> with an empty initializer list in this case</li>
<li>arrays whose elements satisfy rule 2: use <code><a class="el" href="../../d2/d41/classarray.html">array(initializer_list_t)</a></code> with the same initializer list in this case</li>
</ul>
</li>
<li>Constructs a JSON array value by creating <code>cnt</code> copies of a passed value. In case <code>cnt</code> is <code>0</code>, an empty array is created.</li>
<li>Constructs the JSON value with the contents of the range <code>[first, last)</code>. The semantics depends on the different types a JSON value can have:<ul>
<li>In case of a <code>#!json null</code> type, <a href="../../../../home/exceptions.md#jsonexceptioninvalid_iterator206">invalid_iterator.206</a> is thrown.</li>
<li>In case of other primitive types (number, boolean, or string), <code>first</code> must be <code>begin()</code> and <code>last</code> must be <code>end()</code>. In this case, the value is copied. Otherwise, <a href="../../../../home/exceptions.md#jsonexceptioninvalid_iterator204"><code>invalid_iterator.204</code></a> is thrown.</li>
<li>In case of structured types (array, object), the constructor behaves as similar versions for <code>std::vector</code> or <code>std::map</code>; that is, a JSON array or object is constructed from the values in the range.</li>
</ul>
</li>
<li>Creates a copy of a given JSON value.</li>
<li>Move constructor. Constructs a JSON value with the contents of the given value <code>other</code> using move semantics. It "steals" the resources from <code>other</code> and leaves it as JSON <code>#!json null</code> value.</li>
</ol>
<h1>Template parameters</h1>
<p><code>CompatibleType</code> : a type such that: </p><pre class="fragment">- `CompatibleType` is not derived from `std::istream`,
- `CompatibleType` is not `basic_json` (to avoid hijacking copy/move constructors),
- `CompatibleType` is not a different `basic_json` type (i.e. with different template arguments)
- `CompatibleType` is not a `basic_json` nested type (e.g., `json_pointer`, `iterator`, etc.)
- `json_serializer&lt;U&gt;` (with `U = uncvref_t&lt;CompatibleType&gt;`) has a `to_json(basic_json_t&amp;, CompatibleType&amp;&amp;)`
   method
</pre><p> <code>BasicJsonType</code>: : a type such that: </p><pre class="fragment">- `BasicJsonType` is a `basic_json` type.
- `BasicJsonType` has different template arguments than `basic_json_t`.
</pre> <h1>Parameters</h1>
<p><code>v</code> (in) : the type of the value to create</p>
<p><code>val</code> (in) : the value to be forwarded to the respective constructor</p>
<p><code>init</code> (in) : initializer list with JSON values</p>
<p><code>type_deduction</code> (in) : internal parameter; when set to <code>#!cpp true</code>, the type of the JSON value is deducted from the initializer list <code>init</code>; when set to <code>#!cpp false</code>, the type provided via <code>manual_type</code> is forced. This mode is used by the functions <code><a class="el" href="../../d2/d41/classarray.html">array(initializer_list_t)</a></code> and <code><a class="el" href="../../dc/dd8/classobject.html">object(initializer_list_t)</a></code>.</p>
<p><code>manual_type</code> (in) : internal parameter; when <code>type_deduction</code> is set to <code>#!cpp false</code>, the created JSON value will use the provided type (only <code>value_t::array</code> and <code>value_t::object</code> are valid); when <code>type_deduction</code> is set to <code>#!cpp true</code>, this parameter has no effect</p>
<p><code>cnt</code> (in) : the number of JSON copies of <code>val</code> to create</p>
<p><code>first</code> (in) : begin of the range to copy from (included)</p>
<p><code>last</code> (in) : end of the range to copy from (excluded)</p>
<p><code>other</code> (in) : the JSON value to copy/move</p>
<h1>Exceptions</h1>
<ol type="1">
<li>/</li>
<li>The function does not throw exceptions.</li>
<li>/</li>
<li>/</li>
<li>The function can throw the following exceptions:<ul>
<li>Throws <a href="../../../../home/exceptions.md#jsonexceptiontype_error301"><code>type_error.301</code></a> if <code>type_deduction</code> is <code>#!cpp false</code>, <code>manual_type</code> is <code>value_t::object</code>, but <code>init</code> contains an element which is not a pair whose first element is a string. In this case, the constructor could not create an object. If <code>type_deduction</code> would have been <code>#!cpp true</code>, an array would have been created. See <code><a class="el" href="../../dc/dd8/classobject.html">object(initializer_list_t)</a></code> for an example.</li>
</ul>
</li>
<li>/</li>
<li>The function can throw the following exceptions:<ul>
<li>Throws <a href="../../../../home/exceptions.md#jsonexceptioninvalid_iterator201"><code>invalid_iterator.201</code></a> if iterators <code>first</code> and <code>last</code> are not compatible (i.e., do not belong to the same JSON value). In this case, the range <code>[first, last)</code> is undefined.</li>
<li>Throws <a href="../../../../home/exceptions.md#jsonexceptioninvalid_iterator204"><code>invalid_iterator.204</code></a> if iterators <code>first</code> and <code>last</code> belong to a primitive type (number, boolean, or string), but <code>first</code> does not point to the first element any more. In this case, the range <code>[first, last)</code> is undefined. See example code below.</li>
<li>Throws <a href="../../../../home/exceptions.md#jsonexceptioninvalid_iterator206"><code>invalid_iterator.206</code></a> if iterators <code>first</code> and <code>last</code> belong to a <code>#!json null</code> value. In this case, the range <code>[first, last)</code> is undefined.</li>
</ul>
</li>
<li>/</li>
<li>The function does not throw exceptions.</li>
</ol>
<h1>Exception safety</h1>
<ol type="1">
<li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li>
<li>No-throw guarantee: this constructor never throws exceptions.</li>
<li>Depends on the called constructor. For types directly supported by the library (i.e., all types for which no <code>to_json()</code> function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value.</li>
<li>Depends on the called constructor. For types directly supported by the library (i.e., all types for which no <code>to_json()</code> function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value.</li>
<li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li>
<li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li>
<li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li>
<li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li>
<li>No-throw guarantee: this constructor never throws exceptions.</li>
</ol>
<h1>Complexity</h1>
<ol type="1">
<li>Constant.</li>
<li>Constant.</li>
<li>Usually linear in the size of the passed <code>val</code>, also depending on the implementation of the called <code>to_json()</code> method.</li>
<li>Usually linear in the size of the passed <code>val</code>, also depending on the implementation of the called <code>to_json()</code> method.</li>
<li>Linear in the size of the initializer list <code>init</code>.</li>
<li>Linear in <code>cnt</code>.</li>
<li>Linear in distance between <code>first</code> and <code>last</code>.</li>
<li>Linear in the size of <code>other</code>.</li>
<li>Constant.</li>
</ol>
<h1>Notes</h1>
<ul>
<li><p class="startli">Overload 5:</p>
<p class="startli">!!! note </p><pre class="fragment">When used without parentheses around an empty initializer list, `basic_json()` is called instead of this
function, yielding the JSON `#!json null` value.
</pre></li>
<li><p class="startli">Overload 7:</p>
<p class="startli">!!! info "Preconditions" </p><pre class="fragment">- Iterators `first` and `last` must be initialized. **This precondition is enforced with an assertion (see
  warning).** If assertions are switched off, a violation of this precondition yields undefined behavior.
- Range `[first, last)` is valid. Usually, this precondition cannot be checked efficiently. Only certain edge
  cases are detected; see the description of the exceptions above. A violation of this precondition yields
  undefined behavior.
</pre><p> !!! warning </p><pre class="fragment">A precondition is enforced with a runtime assertion that will result in calling `std::abort` if this
precondition is not met. Assertions can be disabled by defining `NDEBUG` at compile time. See
&lt;https://en.cppreference.com/w/cpp/error/assert&gt; for more information.
</pre></li>
<li><p class="startli">Overload 8:</p>
<p class="startli">!!! info "Postcondition" </p><pre class="fragment">`#!cpp *this == other`
</pre></li>
<li><p class="startli">Overload 9:</p>
<p class="startli">!!! info "Postconditions" </p><pre class="fragment">- `#!cpp `*this` has the same value as `other` before the call.
- `other` is a JSON `#!json null` value
</pre> <h1>Example</h1>
</li>
</ul>
<p>??? example </p><pre class="fragment">The following code shows the constructor for different `value_t` values.

```cpp
--8&lt;-- "examples/basic_json__value_t.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__value_t.output"
```
</pre><p> ??? example </p><pre class="fragment">The following code shows the constructor with and without a null pointer parameter.

```cpp
--8&lt;-- "examples/basic_json__nullptr_t.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__nullptr_t.output"
```
</pre><p> ??? example </p><pre class="fragment">The following code shows the constructor with several compatible types.

```cpp
--8&lt;-- "examples/basic_json__CompatibleType.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__CompatibleType.output"
```
</pre><p> ??? example </p><pre class="fragment">The example below shows how JSON values are created from initializer lists.

```cpp
--8&lt;-- "examples/basic_json__list_init_t.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__list_init_t.output"
```
</pre><p> ??? example </p><pre class="fragment">The following code shows examples for creating arrays with several copies of a given value.

```cpp
--8&lt;-- "examples/basic_json__size_type_basic_json.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__size_type_basic_json.output"
```
</pre><p> ??? example </p><pre class="fragment">The example below shows several ways to create JSON values by specifying a subrange with iterators.

```cpp
--8&lt;-- "examples/basic_json__InputIt_InputIt.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__InputIt_InputIt.output"
```
</pre><p> ??? example </p><pre class="fragment">The following code shows an example for the copy constructor.

```cpp
--8&lt;-- "examples/basic_json__basic_json.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__basic_json.output"
```
</pre><p> ??? example </p><pre class="fragment">The code below shows the move constructor explicitly called via `std::move`.

```cpp
--8&lt;-- "examples/basic_json__moveconstructor.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__moveconstructor.output"
```
</pre> <h1>Version history</h1>
<ol type="1">
<li>Since version 1.0.0.</li>
<li>Since version 1.0.0.</li>
<li>Since version 2.1.0.</li>
<li>Since version 3.2.0.</li>
<li>Since version 1.0.0.</li>
<li>Since version 1.0.0.</li>
<li>Since version 1.0.0.</li>
<li>Since version 1.0.0.</li>
<li>Since version 1.0.0. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
